# Randomized Algorithms

- neuer algorithmischer Elementarschritt 
  - Beschaffung eines zufälligen Wertes *randInt(c : *&Nopf;)* liefere zufällig gleichverteilt eine ganze Zahl x ∈ {0, 1, . . . ,c − 1}
- Fundamentale Änderung: Mehrere Ausführungen desselben Algorithmus für die gleiche Eingabe führen können verschieden sein!
- *Beispiel*: Randomized Quicksort
  - benötigte Laufzeit
  - benötigter Speicherplatz
  - berechnete Ergebnis
  - sind alles Zufallsvariablen
- Algorithm with 
  - unknown time complexity (Do we really want that?)
  - varying output
  - wrong output
- Vorteile:
  - leichter zu formulieren und  zu implementieren
  - "schneller"
  - "Besser"
  - einzige Möglichkeit
  - BUT: you always have to pay a price for that
- **Monte Carlo** - A Monte Carlo algorithm has a deterministic asymptotic runtime.
  But it can produce an incorrect result with a small probability *p*. Repeating
  the algorithm *k* times, the probability of failure can be quickly decreased
  down to $p^k$. This technique is called *probability boosting*.
- **Las Vegas** - A Las Vegas algorithm always produces a correct result. But the
  asymptotic runtime of the algorithm is a random variable. Examples for this
  kind of algorithms include quicksort and hashing.
- NOTE: A Monte Carlo algorithm can always be transformed into a Las Vegas algorithm
  by repeated executions until a correct result is achieved. 



### Example Sorting

- Given: Two lists $s = <e_1, e_2, …,e_n>$ and $s' = <e'_1, e'_2, …,e'_n>$ 

  - Question: Do both contain same elements?

  ​

- Easy to verify if a algorithm produces a sorted output

- More complicated and time consuming to verify if output is a permutation of the input

- Naive approach: O(n^2 ) &rarr; compare any entry of s with s'

- Polynoms

- &rarr; Randomized Algorithms help us to check this property in linear time with high probability

- For a sequence $s = <e_1, e_2, …,e_n>$ is a permutation of a sequence $s' = <e'_1, e'_2, …,e'_n>$ if and only if the polynomial  $y = e(z) - a(z) =\prod\limits_{i=1}^{n} (z - field(key(e_i))) - \prod\limits_{i=1}^{n} (z - field(key(e'_i))) = 0$ 

- Error probability: $Pr[e(c) - a(c) = 0 \wedge e(z) - a(z)  not zero plynomial] \leq \frac{n}{|\mathbb{F}|}$

- The proposed algorithm for that scenario is a *Monte Carlo* algorithm


Algo:

```python
	c = randomValue
	y = e(c) - a(c)
    if y == 0: 
      return e == a 
   	else: 
      return e != a
		
```


###Randomized Quicksort

- Erwartungswert E = 2n ln(n)
- Anzahl Vergleiche immer zwischen *n*ln*n* und $n^2$ 
- Erwartete Laufzeit in $\Theta(nln n)$ 


### Example Hashing

- **Hash Tables** - implementation of an *associative array* or *dictionary*
  - Associative array stores a set of elements and supports the operations *insert, remove* and *lookup*. Each element has an associated unique key by which it is identified (e.g. Java HashMaps).
  - **Collisions**: Mapping distinct elements to the same table entry
    - Solutions: *Hashing with chaining, linear probing* and *double hashing* 
    - Need O(n) space

#### Perfect Hashing

- hashing without collision
  - Worst case cconstant time for lookup and remove
- In order to avoid collisions and injective hash function is required
- However, perfect hash functions need much more space



#### Cuckoo Hashing

- basic cuckoo hashing
  - uses hash table of size 2(1 + &epsilon;)*n* to store *n* elements (space overhead of factor 2!!)
  - Two hashfunctions $h_1(\cdot) $ and $h_2(\cdot) $ are applied to store an element
  - Procedure: 
    - Lookup and removal in constant time
    - Insert:
      - if $x$ is not in in hash table &rarr; tested by $h_1(\cdot)$ 
      - if position is occupied by $y$, $x$ replaces $y$ (like a European cuckoo swaps his egg with another one in a nest)
      - Then $y$ is inserted at $h_2(y)$ 
      - If this position is also occupied the procedure repeats
    - Rehashing takes O(n) time and has a probability of P[rehash necessary] = 1 / n
    - The armotized time is O(1)
- **Lemma**
  Inserting a new element x requires a rehash iff the component containing h1(x) and h2(x) in the cuckoo graph contains more edges than nodes.

### Random Graph Theory

- *Random Graph* is a graph that is generated by some random process
- Random graphs following have certain properties with high probability 
- Erdōs-Rényi-Zufallsgraphen



```python
def graph(n,p):
    V = [1,...,n]
    E = []
    for i in range(1, n-1):
        for j in range(i+1, n):
            edge = (i,j) 
            E.append(edge) #with probability p
    return (V,E)
```

mitunter p von n abhängig &rarr; p = p(n) = $\frac{\ln n}{n}$





### Chernoff-Schranken

- Einfache Schranken:
  - Markov-Ungleichung
  - Chebyshev-Ungleichung
- Chernoff
  - $\forall $ $\delta \geq 0$: $Pr[X \geq (1 +\delta)\mu] \leq (\frac{e^\delta}{(1+\delta)^{(1+\delta)}})^\mu$
  - $\forall$  $1 > \delta \geq 0$: $Pr[X \leq (1 -\delta)\mu] \leq (\frac{e^{-\delta}}{(1-\delta)^{(1-\delta)}})^\mu \leq e^{-\delta^2 \mu/2}$

### UND-ODER-Bäume

- Es sei $T_k$ vollständiger binärer Baum der Höhe 2k
- innere Knoten abwechselnd mit "$\wedge$" und "$\vee$"
- Wurzel von $T_1$ ist $\wedge$-Knoten mit zwei $\vee$ -Knoten als Nachfolger
- Jeder Knoten jat zwei Blätter als Nachfolger
- T_k hat n = $4^k$ Blätter
- Boolsche Werte an allen Blättern &rarr; boolscher Wert für Wurzel
- Problem: 
  - Gegeben: Werte x1, x2, …. , xn an den Blättern
  - Gesucht: Wert $T_k(x_1,…,x_n)$ der Wurzel
- Berechnung des Wurzelwertes "bottum up" durch
  - Besuch aller n = 4$^k$ Blätter und
  - Berechnung der Werte aller inneren Knoten möglich

**SATZ**

Für jeden deterministischen Algorithmus A und jedes k $\geq$ 1 gilt:

- Es gibt eine Folge x1,…,xn von Bits so, dass A bei Berechnung von T$_k$ (x1,…xn) alle n = 4$^k$ Blätter besucht.
- Wert der Wurzel = Wert des zuletzt besuchten Blattes
- sowohl Wurzelwert = 0 als auch Wurzelwert = 1 kann erzwungen werden



```python
def and_node_eval(node):
    if isleaf(node):
        return node.val
    tempNode = random(node_And_tree)
    r = or_node_eval(tempNode)
    if r == 0:
        return 0
    tempNode = and

		
```



**SATZ**

Für die randomisierte Auswertung von UOB gilt:

Für jede Folge x1,…,$x_{4^k}$ ist der Erwartungswert für die Anzahl an besuchter Blätter <= $3^k = n^{log_43} \approx n ^{0.792…}$ 

